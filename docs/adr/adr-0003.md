# ADR-0003: Multi-Parameter Functions Over Currying

- **Status:** Accepted
- **Date:** February 1, 2026
- **Context:** Need function syntax that's clear to ops teams without functional programming background

## Problem

Functional languages traditionally use curried functions where multi-argument functions are actually single-argument functions returning functions:

```haskell
-- Haskell style (curried)
add :: Int -> Int -> Int
add x y = x + y

-- This is really:
add :: Int -> (Int -> Int)
add = \x -> \y -> x + y

-- Partial application is natural:
add5 :: Int -> Int
add5 = add 5
```

**For Strata's target audience (ops teams from Python/Go/Rust backgrounds), this is:**
- **Unfamiliar** - They expect `fn(a, b, c)` not `fn(a)(b)(c)`
- **Confusing** - Type signatures like `Int -> Int -> Int` look flat but have hidden structure
- **Unintuitive** - Partial application is powerful but rarely needed in automation scripts
- **Hard to debug** - Accidentally missing an argument returns a function instead of erroring

## Decision

**Use multi-parameter functions with explicit tupling for partial application when needed.**

### Syntax

**Function Definition:**
```strata
fn add(x: Int, y: Int) -> Int {
  x + y
}
```

**Type Signature:**
```strata
add: (Int, Int) -> Int
```

**Function Call:**
```strata
let result = add(5, 3);  // 8
```

**Partial Application (Explicit):**
```strata
// If you want partial application, make it explicit:
fn add5(y: Int) -> Int {
  add(5, y)
}

// Or use a lambda:
let add5 = |y| add(5, y);
```

**Higher-Order Functions:**
```strata
fn map<T, U>(f: (T) -> U, xs: List<T>) -> List<U> {
  // ...
}

// Call with clear single-argument function:
let doubled = map(|x| x * 2, numbers);
```

## Rationale

### Clarity for Target Audience

**Strata targets ops teams who know Python, Go, Rust, JavaScript:**

Python:
```python
def add(x, y):
    return x + y
```

Go:
```go
func add(x int, y int) int {
    return x + y
}
```

Rust:
```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

**All use multi-parameter syntax. Strata should too.**

### Error Messages Are Clearer

**With currying:**
```haskell
add 5  -- Type: Int -> Int (accidentally returns function)
```
User thinks: "I called add with 5, where's my result?"

**With multi-param:**
```strata
add(5)  // Compiler error: Function 'add' expects 2 arguments, got 1
```
User thinks: "Oh, I forgot the second argument."

### Type Signatures Match Intuition

**Curried (confusing):**
```haskell
http_get :: Url -> NetCap -> Result<Bytes, NetErr>
-- Is NetCap a parameter or part of the return type?
-- You have to count arrows and know associativity rules.
```

**Multi-param (clear):**
```strata
fn http_get(url: Url, using net: NetCap) -> Result<Bytes, NetErr> & {Net}
-- Parameters are in parentheses, return type is after ->, effects after &
-- Visually unambiguous.
```

### Partial Application Is Rare in Ops Scripts

**In functional programming research code:**
```haskell
-- Partial application is idiomatic
add5 = add 5
map (add 5) [1,2,3]
```

**In ops automation:**
```python
# You usually call functions with all arguments
response = http_get(url, timeout=30)
deploy_model(model_path, endpoint, config)

# If you need reusable config, you make it explicit:
def deploy_to_staging(model_path):
    return deploy_model(model_path, STAGING_ENDPOINT, STAGING_CONFIG)
```

Strata follows the ops pattern: full calls by default, explicit helpers when needed.

### Capability Passing Is Clearer

**With multi-param:**
```strata
fn read_and_send(
  path: String,
  url: Url,
  using fs: FsCap,
  using net: NetCap
) -> Result<(), Error> & {FS, Net}
```

**With currying (confusing):**
```strata
fn read_and_send(path: String) -> (Url -> FsCap -> NetCap -> Result<(), Error>)
-- Which parameters are data vs capabilities?
-- How do effects compose?
```

Multi-param keeps data parameters and capability parameters visually distinct.

## Alternatives Considered

### Alternative 1: Full Currying (Haskell-Style)
**Rejected because:**
- Unfamiliar to target audience
- Type signatures are harder to read
- Accidental partial application causes confusing bugs
- Doesn't match ops team mental models

### Alternative 2: Currying with Tuple Sugar
Some languages (OCaml, F#) use tuples for multi-arg but desugar to currying:
```ocaml
(* OCaml *)
let add (x, y) = x + y  (* Type: int * int -> int *)
let add x y = x + y     (* Type: int -> int -> int *)
```

**Rejected because:**
- Two ways to do the same thing (confusing)
- Implementation complexity for minimal benefit
- Still doesn't match ops team expectations

### Alternative 3: No Higher-Order Functions
Just ban functions as values entirely.

**Rejected because:**
- Higher-order functions ARE useful (map, filter, etc.)
- We just need them to be explicit, not implicit via currying

## Implementation

### Type System Representation

**Multi-param arrow:**
```rust
pub enum Ty {
    // ...
    Arrow(Vec<Ty>, Box<Ty>),  // Arrow([A, B, C], D) = (A, B, C) -> D
}
```

**Not:**
```rust
Arrow(Box<Ty>, Box<Ty>)  // Would represent currying: A -> (B -> C)
```

### Type Checking

**Function call with N arguments must unify with Arrow of N parameters:**
```rust
fn check_call(fn_ty: Ty, args: Vec<Expr>) -> Result<Ty, TypeError> {
    match fn_ty {
        Ty::Arrow(params, ret) => {
            if params.len() != args.len() {
                return Err(TypeError::ArityMismatch {
                    expected: params.len(),
                    got: args.len(),
                });
            }
            // Check each argument against corresponding parameter
            for (param_ty, arg) in params.iter().zip(args.iter()) {
                let arg_ty = infer_expr(arg)?;
                unify(param_ty, &arg_ty)?;
            }
            Ok(*ret)
        }
        _ => Err(TypeError::NotAFunction),
    }
}
```

**Arity mismatches are caught at compile time:**
```strata
fn add(x: Int, y: Int) -> Int { x + y }

let bad = add(5);  // Error: Function 'add' expects 2 arguments, got 1
```

### Partial Application (When Needed)

**User can create explicit wrapper:**
```strata
fn add5(y: Int) -> Int {
  add(5, y)
}
```

**Or use lambda syntax:**
```strata
let add5 = |y| add(5, y);
```

**This makes partial application:**
- Explicit (you see the lambda/wrapper)
- Intentional (not accidental)
- Greppable (can find all partial applications)

## Consequences

### Positive
- **Familiar to target audience** - Matches Python/Go/Rust conventions
- **Clear error messages** - Arity mismatches caught immediately
- **Readable type signatures** - `(Int, Int) -> Int` is unambiguous
- **Explicit capabilities** - `using cap: Type` syntax is clear
- **No accidental partial application** - Functions must be called with all arguments

### Negative
- **No automatic partial application** - Have to write lambdas explicitly
  - **Mitigation:** This is rarely needed in ops scripts, and explicitness is good
- **Can't pointfree compose as easily** - `let h = f . g` style composition is harder
  - **Mitigation:** Composition operator can still work with single-arg functions
- **Deviates from functional programming tradition** - Haskell/ML programmers might be surprised
  - **Mitigation:** Target audience is ops teams, not FP researchers

### Trade-Offs
- **We optimize for:** Clarity, familiarity, explicit intent
- **We trade off:** Automatic currying elegance, pointfree style
- **We accept:** Slightly more verbose partial application when needed

## Success Criteria

**This decision succeeds if:**
1. Developers from Python/Go/Rust backgrounds find function syntax intuitive
2. Arity mismatch errors are clear and caught early
3. Code reviews rarely involve confusion about partial application
4. Higher-order functions (map, filter) are still ergonomic

**This decision fails if:**
1. Users frequently complain that partial application is too verbose
2. Functional programmers find the language hostile
3. Higher-order function usage is awkward

## Examples

### Before (Curried):
```strata
fn deploy_model(path: String) -> (Url -> FsCap -> NetCap -> Result<Id, Err>)

let step1 = deploy_model("/models/v2.pkl");  -- Type: Url -> FsCap -> NetCap -> Result
let step2 = step1(prod_url);                  -- Type: FsCap -> NetCap -> Result
let step3 = step2(fs_cap);                    -- Type: NetCap -> Result
let result = step3(net_cap);                  -- Type: Result<Id, Err>
```

**Issues:**
- Hard to tell what's happening at each step
- Accidental partial application creates confusing intermediate types
- Can't tell from signature which params are data vs capabilities

### After (Multi-Param):
```strata
fn deploy_model(
  path: String,
  url: Url,
  using fs: FsCap,
  using net: NetCap
) -> Result<Id, Err> & {FS, Net}

let result = deploy_model("/models/v2.pkl", prod_url, using fs_cap, using net_cap);
```

**Better:**
- One clear call with all arguments
- Visually distinct data params vs capability params
- Type signature matches call site
- No accidental partial application

### Partial Application When Needed:
```strata
// Explicit helper for common case
fn deploy_to_staging(path: String, using fs: FsCap, using net: NetCap) -> Result<Id, Err> & {FS, Net} {
  deploy_model(path, STAGING_URL, using fs, using net)
}

// Or lambda for one-off use
let deployers = vec![
  |path| deploy_model(path, staging_url, using fs, using net),
  |path| deploy_model(path, prod_url, using fs, using net),
];
```

## References

- Python function syntax: https://docs.python.org/3/tutorial/controlflow.html#defining-functions
- Go function syntax: https://go.dev/tour/basics/4
- Rust function syntax: https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
- OCaml's dual syntax: https://v2.ocaml.org/manual/coreexamples.html#s%3Atut-recvariants
- Haskell currying: https://wiki.haskell.org/Currying

## Future Considerations

- **Named arguments:** `deploy_model(path: "/models/v2.pkl", url: prod_url)` could improve clarity further
- **Default arguments:** Common in ops languages, might be useful
- **Keyword-only arguments:** Force certain parameters to be named (good for capabilities?)

These are deferred to later versions but compatible with multi-param design.
