# ADR-0005: Effect System

**Date:** February 5, 2026
**Status:** Accepted
**Issue:** 008

## Context

Strata's core differentiator is compile-time effect tracking. Every side effect (file I/O, network access, timing, randomness, AI calls) must appear in function types and be enforced by the type checker. This prevents hidden side effects and enables capability-based security.

## Decision

### Effect Representation

Effects use a **bitmask-based EffectRow** with 5 built-in effects:

| Effect | Bit | Purpose |
|--------|-----|---------|
| Fs     | 0   | Filesystem access |
| Net    | 1   | Network access |
| Time   | 2   | Time/clock access |
| Rand   | 3   | Randomness |
| Ai     | 4   | AI model calls |

Effect rows have the form `{ concrete: u64, tail: Option<EffectVarId> }`:
- **Closed rows** (tail = None): fully known set of effects, e.g., `{Fs, Net}`
- **Open rows** (tail = Some(e)): known effects plus an unknown tail, used during inference

### Syntax

```strata
// Effect annotation on functions
fn read(path: String) -> String & {Fs} { ... }

// Multiple effects
fn fetch_and_save(url: String, path: String) -> () & {Fs, Net} { ... }

// Pure function (explicit)
fn add(x: Int, y: Int) -> Int & {} { x + y }

// Pure function (implicit - no annotation needed)
fn add(x: Int, y: Int) -> Int { x + y }

// Extern functions (no body)
extern fn read_file(path: String) -> String & {Fs};
```

### Inference Strategy

- **Unannotated functions** get a fresh open effect row. Effects are inferred from the function body.
- **Annotated functions** get a closed effect row from the annotation. The body's effects must be a subset.
- **Call sites** create a fresh effect var for each call and emit:
  1. A type equality constraint that unifies the callee's effect row
  2. An `EffectSubset(callee_eff, body_eff)` constraint propagating effects upward

### Two-Phase Constraint Solver

- **Phase A:** Process type equality constraints through the unifier. This resolves callee effect rows via Remy-style row unification.
- **Phase B:** Process EffectSubset constraints by accumulating required effects per effect variable to a fixpoint, then checking all constraints.

### Remy-Style Row Unification

Effect rows unify similarly to record type rows:
- Closed + Closed: bitmask equality
- Closed + Open: bind tail to residual effects
- Open + Open: bind one tail to the other with residual

### Scheme Instantiation

Effect variables in type schemes are instantiated with fresh effect variable IDs, symmetric with type variable instantiation. This ensures that each call to a polymorphic function gets independent effect tracking.

The `Scheme::instantiate` method takes pre-generated slices of fresh types and effect IDs (not closures) to avoid Rust borrow checker issues with multiple `&mut self` borrows.

### Generalization

Effect variables are generalized alongside type variables: `free_effect_vars(ty) \ free_effect_vars(env)` become universally quantified in the scheme.

### Open-Open Effect Subset Binding

When the solver encounters `EffectSubset(sub, sup)` and both have open tails, it binds `sup`'s tail to follow `sub`'s tail. This preserves the structural relationship through generalization, enabling correct effect propagation through higher-order functions. Without this binding, the body effect and callee effect would be independent variables in the generalized scheme, losing the propagation relationship.

### Extern Function Effect Requirements

Extern functions must explicitly declare their effect annotation (`& {Fs}`, `& {}`, etc.). Omitting the annotation is a compile-time error. This prevents accidental "silent pure" defaults that would bypass the effect system.

### Effect Substitution Cycle Detection

Effect variable substitution uses two layers of defense against cycles:
1. **Pre-binding occurs check** (`effect_var_occurs_in`): Before binding an effect variable to an open row, verify the target row's chain doesn't lead back to the variable being bound.
2. **Resolution-time cycle detection** (`apply_effect_row`): Uses a visited set during chain traversal to catch cycles that slip past the occurs check (e.g., through concurrent constraint solving).

Both layers return explicit errors (`SubstError::EffectCycle`) rather than silently truncating. The substitution layer never returns partial results.

### Canonical Variable Resolution in Fixpoint Solver

The fixpoint solver (Phase B, Step 2) resolves alias chains to canonical (terminal) effect variable IDs before HashMap lookups. Without this, aliased variables (e.g., `e3 → e1 → e0`) would be tracked under different keys, causing the fixpoint to miss required effect propagation. The `canonical_effect_var` method chases substitution chains to the end, with cycle protection.

### Scheme Instantiation Arity Safety

`Scheme::instantiate` validates that the number of fresh type variables and effect variables matches the scheme's forall-bound counts. This check is enforced at runtime (not just debug_assert) to prevent silent truncation from `zip()` in release builds, which could cause polymorphic functions to instantiate with fewer variables than expected.

## Alternatives Considered

1. **Row types with labels** (like Koka or Eff): More general but significantly more complex. Bitmask approach is O(1) for all operations and sufficient for our 5 fixed effects.

2. **Subeffecting via subtyping**: Would require a more complex type system with subtyping. Subset constraints are simpler and more predictable.

3. **Effect handlers** (like algebraic effects): Deferred to a future issue. The current system tracks effects but doesn't provide effect handler syntax.

## Consequences

- Every function's side effects are visible in its type
- Pure functions are guaranteed pure by the type checker
- Effect mismatches produce compile-time errors
- Constructors are always pure (no effect propagation)
- Existing pure code (292 tests) continues to work unchanged
