# ADR-0003: ADTs and Pattern Matching

**Status:** Accepted  
**Date:** February 4, 2026  
**Issue:** 007  
**Reviewers:** ChatGPT (Production Engineering), Gemini (Type Theory), Grok (Adversarial Security)

## Context

Strata v0.0.7.0 has a working type system with constraint-based Hindley-Milner inference, functions with let-polymorphism, blocks, control flow, and security hardening. Issue 007 adds algebraic data types (structs, enums), generics, and pattern matching — foundational features required for real-world automation code.

Strata's core value proposition is **capability security**: code cannot perform effects without explicit capability tokens. This constraint heavily influenced our ADT design decisions.

## Decision Drivers

1. **Soundness over ergonomics** — A type system that lies is worse than no type system
2. **Capability security** — Authority cannot be accidentally duplicated or smuggled
3. **Nominality** — Types should be distinguishable for auditing and security
4. **Restrictive-then-relaxed** — Better to forbid now and relax later than ship insecure defaults
5. **Ship v0.1** — Don't let perfect be the enemy of good; defer non-essential features

## Decisions

### D1: Structs — Named Fields, Nominal

**Decision:** Support structs with named fields as nominal types.

```strata
struct Point { x: Int, y: Int }
struct Person { name: String, age: Int }
```

**Rationale:** Standard product types. Nominal by default — `Point` is distinct from any other `{ x: Int, y: Int }`.

---

### D2: Enums — Unit and Tuple Variants Only

**Decision:** Support unit variants (`None`) and tuple variants (`Some(T)`). Defer struct variants.

```strata
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**Deferred:**
```strata
// NOT in v0.1:
enum Message {
    Move { x: Int, y: Int },  // Struct variant
}
```

**Rationale:** 
- Unit + tuple variants cover 90% of use cases (Option, Result, error enums)
- Struct variants create "type-level shadows" and complicate the constructor-as-function model
- Keeps exhaustiveness checking simpler
- Can add in v0.2 without breaking changes

---

### D3: Tuple Types — Nominal Built-ins

**Decision:** Implement tuples as built-in nominal types with syntax sugar.

```strata
// These are equivalent:
let pair: (Int, String) = (1, "hello");
let pair: Tuple2<Int, String> = (1, "hello");
```

**Implementation:**
- Built-in nominal types: `Tuple2<A, B>` through `Tuple8<A, B, C, D, E, F, G, H>`
- Syntax `(a, b)` desugars to `Tuple2` construction
- Pattern `(x, y)` desugars to `Tuple2` destructuring

**Constraints:**
- Max arity: 8
- Max nesting: 3 levels
- Invariant — no variance, `(Never, Int)` does not unify with `(T, Int)`

**Rationale:**
- Ergonomics: multi-return is constant in automation code
- Security: nominal types preserve auditability (cap presence visible in signatures)
- Consistency: tuples inherit all ADT restrictions including caps-in-ADTs ban

**Rejected alternatives:**
- (A) Defer tuples — Too much friction for basic use cases
- (B) Structural tuples — Breaks nominality, enables capability smuggling
- (D) Anonymous struct sugar — Confusing semantics, invites structural expectations

---

### D4: Generics — Type Parameters on ADTs

**Decision:** Support generic type parameters on structs and enums.

```strata
struct Pair<A, B> { fst: A, snd: B }

enum Option<T> {
    Some(T),
    None,
}

fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
    match opt {
        Option::Some(x) => x,
        Option::None => default,
    }
}
```

**Constraints:**
- Max type parameters: 16 per ADT
- Constructors are polymorphic functions: `None : ∀T. () -> Option<T>`
- Fresh type variable instantiated at each constructor call site

**Rationale:** Essential for `Option<T>`, `Result<T, E>`, and generic data structures.

---

### D5: Match Expressions — Exhaustive with Maranget

**Decision:** Implement match expressions with mandatory exhaustiveness checking.

```strata
fn describe(opt: Option<Int>) -> String {
    match opt {
        Option::Some(n) => format("Got {}", n),
        Option::None => "Nothing",
    }
}
```

**Semantics:**
- Scrutinee evaluated exactly once
- Arms evaluated top-to-bottom
- First matching arm wins
- Non-exhaustive match = **compile error**
- Unreachable arm = **warning**

**Algorithm:** Maranget's matrix-reduction algorithm for exhaustiveness and redundancy detection.

**Match type inference:**
- Type of match = join of all arm types
- `Never` arms don't contribute to result type
- All-`Never` match returns `Never`
- Match on `Never` scrutinee is exhaustive with zero arms

**Rationale:**
- Exhaustiveness errors are essential for "safe automation" — partial matches hide bugs
- Redundancy warnings catch dead code (security concern: unexecuted authority checks)
- Maranget is the industry standard for ML-family languages

---

### D6: Pattern Syntax

**Decision:** Support nested patterns, wildcards, literals, and variable binders.

```strata
match value {
    Option::Some(Option::Some(x)) => x,      // Nested
    Option::Some(Option::None) => 0,         // Nested unit
    Option::None => -1,                       // Unit
}

match point {
    Point { x: 0, y } => handle_origin(y),   // Literal + binder
    Point { x, y: 0 } => handle_axis(x),     // Binder + literal  
    Point { x, y } => handle_general(x, y),  // All binders
}

match n {
    0 => "zero",                              // Literal
    1 => "one",
    _ => "many",                              // Wildcard
}
```

**Binding rules:**
- `_` — wildcard, no binding, matches anything
- `_name` — binds but warns "unused" (Rust semantics)
- `name` — binds to matched value
- Duplicate names forbidden: `Pair(x, x)` is compile error
- Shadowing allowed: pattern `x` shadows outer scope `x`

**Constraints (DoS protection):**
- Pattern depth limit: 512 (matches parser nesting)
- Pattern node count limit: 1024
- Variants per enum: 256

**Deferred:**
- Match guards (`if x > 0`) — makes exhaustiveness undecidable
- Or-patterns (`A | B`) — post-v0.1
- Rest patterns (`..`) — post-v0.1
- Range patterns (`0..10`) — post-v0.1

---

### D7: Destructuring Let — Irrefutable Only

**Decision:** Support destructuring let for irrefutable patterns only.

```strata
// Allowed (irrefutable):
let (a, b) = get_pair();
let Point { x, y } = get_point();

// Not allowed (refutable):
// let Option::Some(x) = opt;  // ERROR: use match instead
```

**Error message:**
```
error: refutable pattern in let-binding
  --> src/main.stra:5:5
   |
 5 |     let Option::Some(x) = opt;
   |         ^^^^^^^^^^^^^^^ pattern can fail
   |
   = help: use `match` for refutable patterns
```

**Rationale:**
- Irrefutable patterns are total — no runtime failure path
- Refutable patterns require answering "what happens on mismatch?"
- Keeps `let` semantics simple; `match` handles conditional logic
- Can add `let ... else` in v0.2 if needed

---

### D8: Capabilities in ADTs — Forbidden

**Decision:** Capabilities cannot be stored in ADTs. Hard compile error.

```strata
// ERROR:
struct Client { net: NetCap, url: String }

// ERROR:
enum MaybeNet { Yes(NetCap), No }

// ERROR:
let x: Option<FsCap> = Option::Some(my_cap);
```

**Error message:**
```
error: capabilities cannot be stored in ADTs
  --> src/main.stra:5:20
   |
 5 |     struct Client { net: NetCap, url: String }
   |                     ^^^ capability type here
   |
   = note: storing capabilities requires linear types (planned for Issue 011)
   = help: pass capabilities as function parameters instead
```

**Implementation:**
- `is_cap_ty(&Ty) -> bool` in `strata-types/src/effects.rs`
- Check during ADT definition and generic instantiation
- Hardcoded list for v0.1: `NetCap`, `FsCap`, `TimeCap`, `RandCap`, `AiCap`

**Workaround:**
```strata
// Instead of storing caps:
struct ClientConfig { url: String, timeout: Int }

fn request(config: ClientConfig, using net: NetCap) -> Response & {Net} {
    http_get(config.url, using net)
}
```

**Rationale:**
- Without linearity, `let b = a;` duplicates any ADT, including its capability fields
- Capability duplication is a "catastrophic soundness failure" for capability security
- Restrictive-then-relaxed: forbid now, relax when Issue 011 adds linear types
- Users can still build real systems by passing caps explicitly to functions

---

### D9: Namespace Rules

**Decision:** Enum variants are namespaced under their enum.

```strata
enum Option<T> { Some(T), None }

// Full path required:
let x = Option::Some(42);
let y = Option::None;

// Future (not v0.1): use imports
// use Option::*;
// let x = Some(42);
```

**Collision rules:**
- Variant names cannot collide with other items at module level
- Struct name and enum name can't be the same
- Constructor `Some` lives in value namespace, `Option` lives in type namespace

**Rationale:** Explicit namespacing avoids ambiguity and matches Rust conventions.

---

## Consequences

### Positive
- Sound type system for ADTs with HM inference
- Capability security preserved — no authority duplication via ADTs
- Nominal tuples provide ergonomics without structural typing risks
- Exhaustiveness checking catches partial matches at compile time
- Clear path to v0.2: struct variants, match guards, linear types

### Negative
- No caps in ADTs limits some patterns until Issue 011
- Nominal tuples are slightly unusual (most languages use structural)
- No struct variants limits some enum patterns

### Known Limitations (v0.1)

- **Exhaustiveness deferred on unresolved types:** When the scrutinee has unresolved type variables (e.g., `match Some(1) { ... }` without type annotation), exhaustiveness checking is skipped. Workaround: annotate the type explicitly or bind to a variable first.
- **Nested enum patterns:** Complex nested patterns may not report exhaustiveness correctly in all cases. Will be addressed in post-007 hardening.

### Risks
- Maranget algorithm implementation complexity
- DoS via large pattern matrices (mitigated by limits)
- User friction from caps-in-ADTs ban (mitigated by clear error messages)

---

## Implementation Phases

| Phase | Focus | Deliverables |
|-------|-------|--------------|
| P1 | AST & Parsing | Parse struct/enum/match/tuple, new AST nodes |
| P2 | Type Representation | `Ty::Adt`, `Ty::Tuple`, generic params |
| P3 | ADT Registration | Register types, constructors as poly functions |
| P4 | Match Inference | Infer match, pattern bindings, caps-in-ADT check |
| P5 | Exhaustiveness | Maranget algorithm, redundancy warnings |
| P6 | Hardening | Edge cases, error messages, DoS limits, destructuring let |

**Estimated time:** 10-14 days

---

## References

- Maranget, Luc. "Warnings for Pattern Matching." Journal of Functional Programming, 2007.
- Issue 007 design review: ChatGPT, Gemini, Grok (3 rounds)
- Prior art: Rust, OCaml, Haskell ADT systems