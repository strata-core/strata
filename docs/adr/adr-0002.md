# ADR-0002: Hierarchical Capability Bundles

- **Status:** Accepted
- **Date:** February 1, 2026
- **Context:** Need ergonomic capability management without sacrificing security visibility

## Problem

As Strata functions grow in complexity, capability signatures become unwieldy:

```strata
fn orchestrate_incident(
  incident: Incident,
  using cap: {
    GitHub.Read, GitHub.Comment, GitHub.PullRequest, GitHub.Issues,
    Slack.Read, Slack.Write, Slack.UserLookup, Slack.ChannelList,
    K8s.Read, K8s.Logs, K8s.Events, K8s.Pods,
    Datadog.Metrics, Datadog.Logs, Datadog.Dashboards,
    PagerDuty.Trigger, PagerDuty.Acknowledge
  }
) & {...} -> Result<Resolution, Error>
```

This is 17 capabilities for a single function. At scale:
- **Unmaintainable** - Hard to read, easy to make mistakes
- **Brittle** - Every capability change requires updating all signatures
- **Not semantic** - List doesn't convey the role/purpose
- **Discourages least-privilege** - Developers copy large capability sets rather than thinking about minimums

## Decision

**Support hierarchical RBAC-style capability bundles with compiler-assisted safety.**

### Syntax

**Bundle Definition:**
```strata
// Define reusable capability bundles
capability IncidentResponder = {
  GitHub: {Read, Comment, Issues},
  Slack: {Read, Write},
  K8s: {Read, Logs},
  PagerDuty: {Trigger, Acknowledge}
}

// Hierarchical sub-roles
capability IncidentResponder.Scribe = {
  GitHub: {Comment, Issues},
  Slack: {Write}
  // Note: Can't trigger pages or access K8s
}

capability IncidentResponder.Analyst = {
  GitHub: {Read},
  K8s: {Read, Logs},
  Datadog: {Metrics, Logs}
  // Note: Can investigate but can't modify or notify
}

capability IncidentResponder.Commander = {
  IncidentResponder,           // Everything from base role
  K8s: {Deploy, Rollback},     // PLUS remediation powers
  PagerDuty: {Escalate}
}
```

**Usage:**
```strata
fn orchestrate_incident(
  incident: Incident,
  using cap: IncidentResponder
) & {...} -> Result<Resolution, Error>

fn document_incident(
  incident: Incident,
  using cap: IncidentResponder.Scribe  // More restrictive role
) & {...} -> Result<Report, Error>
```

### Compiler Safety Features

**1. Over-Permission Warnings:**
```strata
fn simple_notify(using cap: IncidentResponder) & {...} -> Result<(), Error> {
  // Implementation only uses Slack.Write
}

// Compiler warning:
// Warning: Function 'simple_notify' requires 'IncidentResponder' but only uses:
//   - Slack.Write
// Consider using a more restrictive capability set or defining:
//   capability Notifier = {Slack.Write}
```

**2. Expansion for Auditing:**
```fish
strata describe role IncidentResponder
# Output:
# Role: IncidentResponder
# Capabilities:
#   GitHub: Read, Comment, Issues
#   Slack: Read, Write
#   K8s: Read, Logs
#   PagerDuty: Trigger, Acknowledge
#
# Sub-roles: Scribe, Analyst, Commander
# Used by: 12 functions across 5 modules
```

**3. Hierarchy Visualization:**
```fish
strata describe role IncidentResponder.Commander --tree
# Output:
# IncidentResponder.Commander
# ├─ IncidentResponder (base)
# │  ├─ GitHub: {Read, Comment, Issues}
# │  ├─ Slack: {Read, Write}
# │  ├─ K8s: {Read, Logs}
# │  └─ PagerDuty: {Trigger, Acknowledge}
# └─ Additional capabilities:
#    ├─ K8s: {Deploy, Rollback}
#    └─ PagerDuty: {Escalate}
```

## Rationale

### Addresses Real-World Pain

**Incident response teams have clear role hierarchies:**
- Scribes document but can't execute changes
- Analysts investigate but can't remediate
- Commanders have full response powers

**Strata's capability bundles map directly to organizational reality.**

### Maintains Security Properties

**Bundles don't compromise security:**
1. Compiler warns on over-permission
2. CLI can expand any bundle for auditing
3. Functions still declare exactly what they use (via bundle names)
4. Principle of least-privilege still enforced (just at bundle level)

### Ergonomics Without Magic

**Bundles are not:**
- Runtime lookups (compile-time expansion)
- Dynamic permission systems (static checks)
- Hidden authority (always visible in signature)

**Bundles are:**
- Named capability sets (like type aliases)
- Compiler-checkable (no new semantics)
- Documentation-friendly (semantic names)

### Inspired by Proven Systems

**AWS IAM:** Managed policies (bundles) + custom policies (fine-grained)
- Learnings: Bundles should have semantic names, be auditable, warn on over-permission

**Kubernetes RBAC:** Roles (bundles) + RoleBindings (usage)
- Learnings: Hierarchical roles (ClusterRole vs Role), least-privilege by default

**Unix groups:** Group membership (bundles) + file permissions (capabilities)
- Learnings: Users can be in multiple groups, permissions compose

## Alternatives Considered

### Alternative 1: Fine-Grained Only
**Rejected because:**
- Verbose at scale (17+ capabilities per function)
- Doesn't match how teams think about roles
- Encourages copy-paste of large capability sets

### Alternative 2: Dynamic Permission Systems
**Rejected because:**
- Loses compile-time checking
- Obscures what code can actually do
- Requires runtime permission lookups
- Not auditable without running code

### Alternative 3: Compiler-Only Abbreviation (No Named Bundles)
**Rejected because:**
- No reusability across functions
- Can't reference "IncidentResponder" role in docs/discussions
- Harder to maintain (change permission, update all callsites)

## Implementation Plan

### Phase 1 (v0.1): Fine-Grained Only
- Implement basic capability syntax: `using cap: {GitHub.Read, Slack.Write}`
- Prove the model works for small examples
- Let users feel the verbosity pain

### Phase 2 (v0.2): Add Capability Bundles
- Implement `capability Name = {...}` definitions
- Support hierarchical composition: `capability X.Y = {...}`
- Bundle expansion at compile-time (desugar to fine-grained)

### Phase 3 (v0.3): Compiler Warnings
- Detect over-permissioned functions
- Suggest minimal capability sets
- Warn on unused bundle capabilities

### Phase 4 (v0.4): CLI Tooling
- `strata describe role <Name>` - Show capability details
- `strata check <file>` - Audit capability usage
- `strata audit` - Generate permission reports

## Consequences

### Positive
- **Ergonomic at scale** - 1 name instead of 17 capabilities
- **Semantic clarity** - "IncidentResponder" conveys intent better than permission list
- **Maintainable** - Update bundle definition, all uses update automatically
- **Maps to reality** - RBAC-style roles match organizational structure
- **Still auditable** - CLI can expand any bundle for inspection

### Negative
- **Temptation to over-permission** - Bundles might be too broad
  - **Mitigation:** Compiler warnings, encourage small focused bundles
- **Learning curve** - Users must learn both fine-grained and bundled styles
  - **Mitigation:** Good docs, clear examples, start with fine-grained
- **Namespace pollution** - Many bundle definitions could clutter code
  - **Mitigation:** Convention of `capabilities/` directory, imports

### Risks
- **Bundle bloat** - Teams might create too many bundles
  - **Monitor:** If >50 bundles in a codebase, guidance needed
- **Hierarchy complexity** - Deep hierarchies (A.B.C.D) might be confusing
  - **Guideline:** Max 2 levels (Base.SubRole), warn on deeper

## Success Criteria

**This decision succeeds if:**
1. Users naturally create capability bundles for their domain roles
2. Code reviews reference bundle names ("this should use Analyst role, not Commander")
3. Compiler warnings catch over-permission regularly
4. Audit tooling makes permission reviews straightforward
5. Security teams trust the model for compliance reporting

**This decision fails if:**
1. Users avoid bundles and stick to verbose fine-grained lists
2. Bundles become too coarse (everyone uses "Admin" bundle)
3. Compiler can't effectively warn on over-permission
4. Audit tooling doesn't provide enough visibility

## References

- AWS IAM Best Practices: https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html
- Kubernetes RBAC: https://kubernetes.io/docs/reference/access-authn-authz/rbac/
- Principle of Least Privilege: https://en.wikipedia.org/wiki/Principle_of_least_privilege
- Object Capability Model: http://erights.org/elib/capability/ode/ode-capabilities.html

## Future Work

- **Capability arithmetic:** `capability A = B ∪ C` or `A = B - {GitHub.Write}`
- **Parameterized bundles:** `capability Reader<T> = {T.Read}` (probably not - keep simple)
- **Standard library bundles:** Ship common roles (ReadOnly, Admin, Auditor)
- **Bundle inheritance analysis:** Tooling to suggest refactoring overlapping bundles
